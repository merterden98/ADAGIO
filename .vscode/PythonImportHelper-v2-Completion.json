[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "t_map",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "t_map",
        "description": "t_map",
        "detail": "t_map",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "mygene",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mygene",
        "description": "mygene",
        "detail": "mygene",
        "documentation": {}
    },
    {
        "label": "Gene",
        "importPath": "t_map.gene.gene",
        "description": "t_map.gene.gene",
        "isExtraImport": true,
        "detail": "t_map.gene.gene",
        "documentation": {}
    },
    {
        "label": "Gene",
        "importPath": "t_map.gene.gene",
        "description": "t_map.gene.gene",
        "isExtraImport": true,
        "detail": "t_map.gene.gene",
        "documentation": {}
    },
    {
        "label": "Gene",
        "importPath": "t_map.gene.gene",
        "description": "t_map.gene.gene",
        "isExtraImport": true,
        "detail": "t_map.gene.gene",
        "documentation": {}
    },
    {
        "label": "Gene",
        "importPath": "t_map.gene.gene",
        "description": "t_map.gene.gene",
        "isExtraImport": true,
        "detail": "t_map.gene.gene",
        "documentation": {}
    },
    {
        "label": "Gene",
        "importPath": "t_map.gene.gene",
        "description": "t_map.gene.gene",
        "isExtraImport": true,
        "detail": "t_map.gene.gene",
        "documentation": {}
    },
    {
        "label": "Gene",
        "importPath": "t_map.gene.gene",
        "description": "t_map.gene.gene",
        "isExtraImport": true,
        "detail": "t_map.gene.gene",
        "documentation": {}
    },
    {
        "label": "Gene",
        "importPath": "t_map.gene.gene",
        "description": "t_map.gene.gene",
        "isExtraImport": true,
        "detail": "t_map.gene.gene",
        "documentation": {}
    },
    {
        "label": "Gene",
        "importPath": "t_map.gene.gene",
        "description": "t_map.gene.gene",
        "isExtraImport": true,
        "detail": "t_map.gene.gene",
        "documentation": {}
    },
    {
        "label": "Gene",
        "importPath": "t_map.gene.gene",
        "description": "t_map.gene.gene",
        "isExtraImport": true,
        "detail": "t_map.gene.gene",
        "documentation": {}
    },
    {
        "label": "Gene",
        "importPath": "t_map.gene.gene",
        "description": "t_map.gene.gene",
        "isExtraImport": true,
        "detail": "t_map.gene.gene",
        "documentation": {}
    },
    {
        "label": "Gene",
        "importPath": "t_map.gene.gene",
        "description": "t_map.gene.gene",
        "isExtraImport": true,
        "detail": "t_map.gene.gene",
        "documentation": {}
    },
    {
        "label": "Gene",
        "importPath": "t_map.gene.gene",
        "description": "t_map.gene.gene",
        "isExtraImport": true,
        "detail": "t_map.gene.gene",
        "documentation": {}
    },
    {
        "label": "Gene",
        "importPath": "t_map.gene.gene",
        "description": "t_map.gene.gene",
        "isExtraImport": true,
        "detail": "t_map.gene.gene",
        "documentation": {}
    },
    {
        "label": "Gene",
        "importPath": "t_map.gene.gene",
        "description": "t_map.gene.gene",
        "isExtraImport": true,
        "detail": "t_map.gene.gene",
        "documentation": {}
    },
    {
        "label": "Glider",
        "importPath": "t_map.feta.glide",
        "description": "t_map.feta.glide",
        "isExtraImport": true,
        "detail": "t_map.feta.glide",
        "documentation": {}
    },
    {
        "label": "Glider",
        "importPath": "t_map.feta.glide",
        "description": "t_map.feta.glide",
        "isExtraImport": true,
        "detail": "t_map.feta.glide",
        "documentation": {}
    },
    {
        "label": "Glider",
        "importPath": "t_map.feta.glide",
        "description": "t_map.feta.glide",
        "isExtraImport": true,
        "detail": "t_map.feta.glide",
        "documentation": {}
    },
    {
        "label": "Glider",
        "importPath": "t_map.feta.glide",
        "description": "t_map.feta.glide",
        "isExtraImport": true,
        "detail": "t_map.feta.glide",
        "documentation": {}
    },
    {
        "label": "Glider",
        "importPath": "t_map.feta.glide",
        "description": "t_map.feta.glide",
        "isExtraImport": true,
        "detail": "t_map.feta.glide",
        "documentation": {}
    },
    {
        "label": "ADAGIO",
        "importPath": "t_map.feta.glide",
        "description": "t_map.feta.glide",
        "isExtraImport": true,
        "detail": "t_map.feta.glide",
        "documentation": {}
    },
    {
        "label": "RandomWalkWithRestart",
        "importPath": "t_map.feta.randomwalk",
        "description": "t_map.feta.randomwalk",
        "isExtraImport": true,
        "detail": "t_map.feta.randomwalk",
        "documentation": {}
    },
    {
        "label": "RandomWalkWithRestart",
        "importPath": "t_map.feta.randomwalk",
        "description": "t_map.feta.randomwalk",
        "isExtraImport": true,
        "detail": "t_map.feta.randomwalk",
        "documentation": {}
    },
    {
        "label": "RandomWalkWithRestart",
        "importPath": "t_map.feta.randomwalk",
        "description": "t_map.feta.randomwalk",
        "isExtraImport": true,
        "detail": "t_map.feta.randomwalk",
        "documentation": {}
    },
    {
        "label": "RandomWalkWithRestart",
        "importPath": "t_map.feta.randomwalk",
        "description": "t_map.feta.randomwalk",
        "isExtraImport": true,
        "detail": "t_map.feta.randomwalk",
        "documentation": {}
    },
    {
        "label": "PreComputeRWR",
        "importPath": "t_map.feta.randomwalk",
        "description": "t_map.feta.randomwalk",
        "isExtraImport": true,
        "detail": "t_map.feta.randomwalk",
        "documentation": {}
    },
    {
        "label": "RandomWalkWithRestart",
        "importPath": "t_map.feta.randomwalk",
        "description": "t_map.feta.randomwalk",
        "isExtraImport": true,
        "detail": "t_map.feta.randomwalk",
        "documentation": {}
    },
    {
        "label": "StringDB",
        "importPath": "t_map.garbanzo.stringdb",
        "description": "t_map.garbanzo.stringdb",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.stringdb",
        "documentation": {}
    },
    {
        "label": "StringDB",
        "importPath": "t_map.garbanzo.stringdb",
        "description": "t_map.garbanzo.stringdb",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.stringdb",
        "documentation": {}
    },
    {
        "label": "StringDB",
        "importPath": "t_map.garbanzo.stringdb",
        "description": "t_map.garbanzo.stringdb",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.stringdb",
        "documentation": {}
    },
    {
        "label": "StringDB",
        "importPath": "t_map.garbanzo.stringdb",
        "description": "t_map.garbanzo.stringdb",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.stringdb",
        "documentation": {}
    },
    {
        "label": "Networkx",
        "importPath": "t_map.garbanzo.networkx",
        "description": "t_map.garbanzo.networkx",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.networkx",
        "documentation": {}
    },
    {
        "label": "Networkx",
        "importPath": "t_map.garbanzo.networkx",
        "description": "t_map.garbanzo.networkx",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.networkx",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "Huri",
        "importPath": "t_map.garbanzo.huri",
        "description": "t_map.garbanzo.huri",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.huri",
        "documentation": {}
    },
    {
        "label": "Huri",
        "importPath": "t_map.garbanzo.huri",
        "description": "t_map.garbanzo.huri",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.huri",
        "documentation": {}
    },
    {
        "label": "Huri",
        "importPath": "t_map.garbanzo.huri",
        "description": "t_map.garbanzo.huri",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.huri",
        "documentation": {}
    },
    {
        "label": "Hummus",
        "importPath": "t_map.hummus.hummus",
        "description": "t_map.hummus.hummus",
        "isExtraImport": true,
        "detail": "t_map.hummus.hummus",
        "documentation": {}
    },
    {
        "label": "Hummus",
        "importPath": "t_map.hummus.hummus",
        "description": "t_map.hummus.hummus",
        "isExtraImport": true,
        "detail": "t_map.hummus.hummus",
        "documentation": {}
    },
    {
        "label": "Hummus",
        "importPath": "t_map.hummus.hummus",
        "description": "t_map.hummus.hummus",
        "isExtraImport": true,
        "detail": "t_map.hummus.hummus",
        "documentation": {}
    },
    {
        "label": "HummusScore",
        "importPath": "t_map.hummus.hummus_score",
        "description": "t_map.hummus.hummus_score",
        "isExtraImport": true,
        "detail": "t_map.hummus.hummus_score",
        "documentation": {}
    },
    {
        "label": "ScoreTypes",
        "importPath": "t_map.hummus.hummus_score",
        "description": "t_map.hummus.hummus_score",
        "isExtraImport": true,
        "detail": "t_map.hummus.hummus_score",
        "documentation": {}
    },
    {
        "label": "HummusScore",
        "importPath": "t_map.hummus.hummus_score",
        "description": "t_map.hummus.hummus_score",
        "isExtraImport": true,
        "detail": "t_map.hummus.hummus_score",
        "documentation": {}
    },
    {
        "label": "ScoreTypes",
        "importPath": "t_map.hummus.hummus_score",
        "description": "t_map.hummus.hummus_score",
        "isExtraImport": true,
        "detail": "t_map.hummus.hummus_score",
        "documentation": {}
    },
    {
        "label": "HummusScore",
        "importPath": "t_map.hummus.hummus_score",
        "description": "t_map.hummus.hummus_score",
        "isExtraImport": true,
        "detail": "t_map.hummus.hummus_score",
        "documentation": {}
    },
    {
        "label": "ScoreFn",
        "importPath": "t_map.hummus.hummus_score",
        "description": "t_map.hummus.hummus_score",
        "isExtraImport": true,
        "detail": "t_map.hummus.hummus_score",
        "documentation": {}
    },
    {
        "label": "HummusScore",
        "importPath": "t_map.hummus.hummus_score",
        "description": "t_map.hummus.hummus_score",
        "isExtraImport": true,
        "detail": "t_map.hummus.hummus_score",
        "documentation": {}
    },
    {
        "label": "reweight_graph_by_tissue",
        "importPath": "t_map.garbanzo.transforms.tissue_reweight",
        "description": "t_map.garbanzo.transforms.tissue_reweight",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.transforms.tissue_reweight",
        "documentation": {}
    },
    {
        "label": "reweight_graph_by_tissue",
        "importPath": "t_map.garbanzo.transforms.tissue_reweight",
        "description": "t_map.garbanzo.transforms.tissue_reweight",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.transforms.tissue_reweight",
        "documentation": {}
    },
    {
        "label": "reweight_graph_by_tissue",
        "importPath": "t_map.garbanzo.transforms.tissue_reweight",
        "description": "t_map.garbanzo.transforms.tissue_reweight",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.transforms.tissue_reweight",
        "documentation": {}
    },
    {
        "label": "merge",
        "importPath": "t_map.garbanzo.merge",
        "description": "t_map.garbanzo.merge",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.merge",
        "documentation": {}
    },
    {
        "label": "merge",
        "importPath": "t_map.garbanzo.merge",
        "description": "t_map.garbanzo.merge",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.merge",
        "documentation": {}
    },
    {
        "label": "merge",
        "importPath": "t_map.garbanzo.merge",
        "description": "t_map.garbanzo.merge",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.merge",
        "documentation": {}
    },
    {
        "label": "Dada",
        "importPath": "t_map.feta.dada",
        "description": "t_map.feta.dada",
        "isExtraImport": true,
        "detail": "t_map.feta.dada",
        "documentation": {}
    },
    {
        "label": "Dada",
        "importPath": "t_map.feta.dada",
        "description": "t_map.feta.dada",
        "isExtraImport": true,
        "detail": "t_map.feta.dada",
        "documentation": {}
    },
    {
        "label": "Dada",
        "importPath": "t_map.feta.dada",
        "description": "t_map.feta.dada",
        "isExtraImport": true,
        "detail": "t_map.feta.dada",
        "documentation": {}
    },
    {
        "label": "PreComputeFeta",
        "importPath": "t_map.feta.feta",
        "description": "t_map.feta.feta",
        "isExtraImport": true,
        "detail": "t_map.feta.feta",
        "documentation": {}
    },
    {
        "label": "PreComputeFeta",
        "importPath": "t_map.feta.feta",
        "description": "t_map.feta.feta",
        "isExtraImport": true,
        "detail": "t_map.feta.feta",
        "documentation": {}
    },
    {
        "label": "Feta",
        "importPath": "t_map.feta.feta",
        "description": "t_map.feta.feta",
        "isExtraImport": true,
        "detail": "t_map.feta.feta",
        "documentation": {}
    },
    {
        "label": "PreComputeFeta",
        "importPath": "t_map.feta.feta",
        "description": "t_map.feta.feta",
        "isExtraImport": true,
        "detail": "t_map.feta.feta",
        "documentation": {}
    },
    {
        "label": "Feta",
        "importPath": "t_map.feta.feta",
        "description": "t_map.feta.feta",
        "isExtraImport": true,
        "detail": "t_map.feta.feta",
        "documentation": {}
    },
    {
        "label": "PreComputeFeta",
        "importPath": "t_map.feta.feta",
        "description": "t_map.feta.feta",
        "isExtraImport": true,
        "detail": "t_map.feta.feta",
        "documentation": {}
    },
    {
        "label": "Feta",
        "importPath": "t_map.feta.feta",
        "description": "t_map.feta.feta",
        "isExtraImport": true,
        "detail": "t_map.feta.feta",
        "documentation": {}
    },
    {
        "label": "PreComputeFeta",
        "importPath": "t_map.feta.feta",
        "description": "t_map.feta.feta",
        "isExtraImport": true,
        "detail": "t_map.feta.feta",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "networkx",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "networkx",
        "description": "networkx",
        "detail": "networkx",
        "documentation": {}
    },
    {
        "label": "to_dict_of_lists",
        "importPath": "networkx",
        "description": "networkx",
        "isExtraImport": true,
        "detail": "networkx",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ContextManager",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "Description",
        "importPath": "t_map.feta.description",
        "description": "t_map.feta.description",
        "isExtraImport": true,
        "detail": "t_map.feta.description",
        "documentation": {}
    },
    {
        "label": "Description",
        "importPath": "t_map.feta.description",
        "description": "t_map.feta.description",
        "isExtraImport": true,
        "detail": "t_map.feta.description",
        "documentation": {}
    },
    {
        "label": "Description",
        "importPath": "t_map.feta.description",
        "description": "t_map.feta.description",
        "isExtraImport": true,
        "detail": "t_map.feta.description",
        "documentation": {}
    },
    {
        "label": "Description",
        "importPath": "t_map.feta.description",
        "description": "t_map.feta.description",
        "isExtraImport": true,
        "detail": "t_map.feta.description",
        "documentation": {}
    },
    {
        "label": "dataclasses",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "dataclasses",
        "description": "dataclasses",
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractproperty",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractproperty",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "dill",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "dill",
        "description": "dill",
        "detail": "dill",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "glide_mat",
        "importPath": "gfunc.command",
        "description": "gfunc.command",
        "isExtraImport": true,
        "detail": "gfunc.command",
        "documentation": {}
    },
    {
        "label": "tree",
        "importPath": "networkx.algorithms",
        "description": "networkx.algorithms",
        "isExtraImport": true,
        "detail": "networkx.algorithms",
        "documentation": {}
    },
    {
        "label": "tree",
        "importPath": "networkx.algorithms",
        "description": "networkx.algorithms",
        "isExtraImport": true,
        "detail": "networkx.algorithms",
        "documentation": {}
    },
    {
        "label": "Garbanzo",
        "importPath": "t_map.garbanzo.garbanzo",
        "description": "t_map.garbanzo.garbanzo",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.garbanzo",
        "documentation": {}
    },
    {
        "label": "Garbanzo",
        "importPath": "t_map.garbanzo.garbanzo",
        "description": "t_map.garbanzo.garbanzo",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.garbanzo",
        "documentation": {}
    },
    {
        "label": "Garbanzo",
        "importPath": "t_map.garbanzo.garbanzo",
        "description": "t_map.garbanzo.garbanzo",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.garbanzo",
        "documentation": {}
    },
    {
        "label": "Garbanzo",
        "importPath": "t_map.garbanzo.garbanzo",
        "description": "t_map.garbanzo.garbanzo",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.garbanzo",
        "documentation": {}
    },
    {
        "label": "Garbanzo",
        "importPath": "t_map.garbanzo.garbanzo",
        "description": "t_map.garbanzo.garbanzo",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.garbanzo",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "EdgeListGarbanzo",
        "importPath": "t_map.garbanzo.edgelist",
        "description": "t_map.garbanzo.edgelist",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.edgelist",
        "documentation": {}
    },
    {
        "label": "EdgeListGarbanzo",
        "importPath": "t_map.garbanzo.edgelist",
        "description": "t_map.garbanzo.edgelist",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.edgelist",
        "documentation": {}
    },
    {
        "label": "EdgeListGarbanzo",
        "importPath": "t_map.garbanzo.edgelist",
        "description": "t_map.garbanzo.edgelist",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.edgelist",
        "documentation": {}
    },
    {
        "label": "EdgeListGarbanzo",
        "importPath": "t_map.garbanzo.edgelist",
        "description": "t_map.garbanzo.edgelist",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.edgelist",
        "documentation": {}
    },
    {
        "label": "EdgeListGarbanzo",
        "importPath": "t_map.garbanzo.edgelist",
        "description": "t_map.garbanzo.edgelist",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.edgelist",
        "documentation": {}
    },
    {
        "label": "EdgeListGarbanzo",
        "importPath": "t_map.garbanzo.edgelist",
        "description": "t_map.garbanzo.edgelist",
        "isExtraImport": true,
        "detail": "t_map.garbanzo.edgelist",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "floor",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "KFold",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "extensions",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = ['.rst', '.md']\nsource_suffix = '.rst'\n# The master toctree document.\nmaster_doc = 'index'",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "templates_path",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "templates_path = ['_templates']\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = ['.rst', '.md']\nsource_suffix = '.rst'\n# The master toctree document.\nmaster_doc = 'index'\n# General information about the project.\nproject = 't-map'",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "source_suffix",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "source_suffix = '.rst'\n# The master toctree document.\nmaster_doc = 'index'\n# General information about the project.\nproject = 't-map'\ncopyright = \"2021, Mert Erden\"\nauthor = \"Mert Erden\"\n# The version info for the project you're documenting, acts as replacement\n# for |version| and |release|, also used in various other places throughout\n# the built documents.",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "master_doc",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "master_doc = 'index'\n# General information about the project.\nproject = 't-map'\ncopyright = \"2021, Mert Erden\"\nauthor = \"Mert Erden\"\n# The version info for the project you're documenting, acts as replacement\n# for |version| and |release|, also used in various other places throughout\n# the built documents.\n#\n# The short X.Y version.",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "project",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "project = 't-map'\ncopyright = \"2021, Mert Erden\"\nauthor = \"Mert Erden\"\n# The version info for the project you're documenting, acts as replacement\n# for |version| and |release|, also used in various other places throughout\n# the built documents.\n#\n# The short X.Y version.\nversion = t_map.__version__\n# The full version, including alpha/beta/rc tags.",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "copyright",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "copyright = \"2021, Mert Erden\"\nauthor = \"Mert Erden\"\n# The version info for the project you're documenting, acts as replacement\n# for |version| and |release|, also used in various other places throughout\n# the built documents.\n#\n# The short X.Y version.\nversion = t_map.__version__\n# The full version, including alpha/beta/rc tags.\nrelease = t_map.__version__",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "author",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "author = \"Mert Erden\"\n# The version info for the project you're documenting, acts as replacement\n# for |version| and |release|, also used in various other places throughout\n# the built documents.\n#\n# The short X.Y version.\nversion = t_map.__version__\n# The full version, including alpha/beta/rc tags.\nrelease = t_map.__version__\n# The language for content autogenerated by Sphinx. Refer to documentation",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "version",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "version = t_map.__version__\n# The full version, including alpha/beta/rc tags.\nrelease = t_map.__version__\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = None\n# List of patterns, relative to source directory, that match files and",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "release",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "release = t_map.__version__\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = None\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "language",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "language = None\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path\nexclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# -- Options for HTML output -------------------------------------------",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "exclude_patterns",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# -- Options for HTML output -------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = 'alabaster'",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "pygments_style",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "pygments_style = 'sphinx'\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# -- Options for HTML output -------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = 'alabaster'\n# Theme options are theme-specific and customize the look and feel of a\n# theme further.  For a list of options available for each theme, see the",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "todo_include_todos",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "todo_include_todos = False\n# -- Options for HTML output -------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = 'alabaster'\n# Theme options are theme-specific and customize the look and feel of a\n# theme further.  For a list of options available for each theme, see the\n# documentation.\n#",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "html_theme",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "html_theme = 'alabaster'\n# Theme options are theme-specific and customize the look and feel of a\n# theme further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "html_static_path",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "html_static_path = ['_static']\n# -- Options for HTMLHelp output ---------------------------------------\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 't_mapdoc'\n# -- Options for LaTeX output ------------------------------------------\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "htmlhelp_basename",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "htmlhelp_basename = 't_mapdoc'\n# -- Options for LaTeX output ------------------------------------------\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    #\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "latex_elements",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "latex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    #\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.\n    #\n    # 'preamble': '',",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "latex_documents",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "latex_documents = [\n    (master_doc, 't_map.tex',\n     't-map Documentation',\n     'Mert Erden', 'manual'),\n]\n# -- Options for manual page output ------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, 't_map',",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "man_pages",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "man_pages = [\n    (master_doc, 't_map',\n     't-map Documentation',\n     [author], 1)\n]\n# -- Options for Texinfo output ----------------------------------------\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "texinfo_documents",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "texinfo_documents = [\n    (master_doc, 't_map',\n     't-map Documentation',\n     author,\n     't_map',\n     'One line description of project.',\n     'Miscellaneous'),\n]",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "get_genelist",
        "kind": 2,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "def get_genelist(genelist_path):\n    df = pd.read_csv(genelist_path)\n    df = df[df[\"score\"] == 1]\n    gl = df[\"STRING_id\"].tolist()\n    gl = [g.removeprefix(\"9606.\") for g in gl]\n    client = mygene.MyGeneInfo()\n    res = client.querymany(gl, scopes=\"symbol,ensembl.protein\",\n                           fields=\"symbol,entrezgene,ensembl.protein\")\n    new_res = []\n    for r in res:",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "ROOT = \"../data/genedise_genelists\"\ndef get_genelist(genelist_path):\n    df = pd.read_csv(genelist_path)\n    df = df[df[\"score\"] == 1]\n    gl = df[\"STRING_id\"].tolist()\n    gl = [g.removeprefix(\"9606.\") for g in gl]\n    client = mygene.MyGeneInfo()\n    res = client.querymany(gl, scopes=\"symbol,ensembl.protein\",\n                           fields=\"symbol,entrezgene,ensembl.protein\")\n    new_res = []",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "genelists_of_interest",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "genelists_of_interest = glob.glob(ROOT + \"/*drugs\")\nglider = Glider()\nrwr = RandomWalkWithRestart()\nls = [g for g in genelists_of_interest]\ngraph = StringDB(ls[0])\nadd_amount = int(0.10 * graph.graph.number_of_edges() /\n                 graph.graph.number_of_nodes())\nglider.setup(graph.graph)\nglider.set_add_edges_amount(add_amount)\nresults = []",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "glider",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "glider = Glider()\nrwr = RandomWalkWithRestart()\nls = [g for g in genelists_of_interest]\ngraph = StringDB(ls[0])\nadd_amount = int(0.10 * graph.graph.number_of_edges() /\n                 graph.graph.number_of_nodes())\nglider.setup(graph.graph)\nglider.set_add_edges_amount(add_amount)\nresults = []\nold_gl = []",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "rwr",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "rwr = RandomWalkWithRestart()\nls = [g for g in genelists_of_interest]\ngraph = StringDB(ls[0])\nadd_amount = int(0.10 * graph.graph.number_of_edges() /\n                 graph.graph.number_of_nodes())\nglider.setup(graph.graph)\nglider.set_add_edges_amount(add_amount)\nresults = []\nold_gl = []\ni = int(sys.argv[1])",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "ls",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "ls = [g for g in genelists_of_interest]\ngraph = StringDB(ls[0])\nadd_amount = int(0.10 * graph.graph.number_of_edges() /\n                 graph.graph.number_of_nodes())\nglider.setup(graph.graph)\nglider.set_add_edges_amount(add_amount)\nresults = []\nold_gl = []\ni = int(sys.argv[1])\ngl = get_genelist(ls[i])",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "graph = StringDB(ls[0])\nadd_amount = int(0.10 * graph.graph.number_of_edges() /\n                 graph.graph.number_of_nodes())\nglider.setup(graph.graph)\nglider.set_add_edges_amount(add_amount)\nresults = []\nold_gl = []\ni = int(sys.argv[1])\ngl = get_genelist(ls[i])\ngraph = Networkx(graph.graph, gl)",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "add_amount",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "add_amount = int(0.10 * graph.graph.number_of_edges() /\n                 graph.graph.number_of_nodes())\nglider.setup(graph.graph)\nglider.set_add_edges_amount(add_amount)\nresults = []\nold_gl = []\ni = int(sys.argv[1])\ngl = get_genelist(ls[i])\ngraph = Networkx(graph.graph, gl)\ng1 = rwr(gl, graph.graph)",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "results",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "results = []\nold_gl = []\ni = int(sys.argv[1])\ngl = get_genelist(ls[i])\ngraph = Networkx(graph.graph, gl)\ng1 = rwr(gl, graph.graph)\ng2 = glider(gl, graph.graph)\nres = {\"rwr\": g1, \"glide\": g2, \"genelist\": l}\nrwr = res[\"rwr\"]\nglider = res[\"glide\"]",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "old_gl",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "old_gl = []\ni = int(sys.argv[1])\ngl = get_genelist(ls[i])\ngraph = Networkx(graph.graph, gl)\ng1 = rwr(gl, graph.graph)\ng2 = glider(gl, graph.graph)\nres = {\"rwr\": g1, \"glide\": g2, \"genelist\": l}\nrwr = res[\"rwr\"]\nglider = res[\"glide\"]\nfile = res[\"genelist\"]",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "i",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "i = int(sys.argv[1])\ngl = get_genelist(ls[i])\ngraph = Networkx(graph.graph, gl)\ng1 = rwr(gl, graph.graph)\ng2 = glider(gl, graph.graph)\nres = {\"rwr\": g1, \"glide\": g2, \"genelist\": l}\nrwr = res[\"rwr\"]\nglider = res[\"glide\"]\nfile = res[\"genelist\"]\ndisease = file.split(\"/\")[-1]",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "gl",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "gl = get_genelist(ls[i])\ngraph = Networkx(graph.graph, gl)\ng1 = rwr(gl, graph.graph)\ng2 = glider(gl, graph.graph)\nres = {\"rwr\": g1, \"glide\": g2, \"genelist\": l}\nrwr = res[\"rwr\"]\nglider = res[\"glide\"]\nfile = res[\"genelist\"]\ndisease = file.split(\"/\")[-1]\nrwr_sorted = sorted(list(rwr), key=lambda x: x[1], reverse=True)",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "graph = Networkx(graph.graph, gl)\ng1 = rwr(gl, graph.graph)\ng2 = glider(gl, graph.graph)\nres = {\"rwr\": g1, \"glide\": g2, \"genelist\": l}\nrwr = res[\"rwr\"]\nglider = res[\"glide\"]\nfile = res[\"genelist\"]\ndisease = file.split(\"/\")[-1]\nrwr_sorted = sorted(list(rwr), key=lambda x: x[1], reverse=True)\nglider_sorted = sorted(list(glider), key=lambda x: x[1], reverse=True)",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "g1",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "g1 = rwr(gl, graph.graph)\ng2 = glider(gl, graph.graph)\nres = {\"rwr\": g1, \"glide\": g2, \"genelist\": l}\nrwr = res[\"rwr\"]\nglider = res[\"glide\"]\nfile = res[\"genelist\"]\ndisease = file.split(\"/\")[-1]\nrwr_sorted = sorted(list(rwr), key=lambda x: x[1], reverse=True)\nglider_sorted = sorted(list(glider), key=lambda x: x[1], reverse=True)\nwith open(f\"./{disease}_glider\", \"w\") as f:",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "g2",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "g2 = glider(gl, graph.graph)\nres = {\"rwr\": g1, \"glide\": g2, \"genelist\": l}\nrwr = res[\"rwr\"]\nglider = res[\"glide\"]\nfile = res[\"genelist\"]\ndisease = file.split(\"/\")[-1]\nrwr_sorted = sorted(list(rwr), key=lambda x: x[1], reverse=True)\nglider_sorted = sorted(list(glider), key=lambda x: x[1], reverse=True)\nwith open(f\"./{disease}_glider\", \"w\") as f:\n    for gene, score in glider_sorted:",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "res",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "res = {\"rwr\": g1, \"glide\": g2, \"genelist\": l}\nrwr = res[\"rwr\"]\nglider = res[\"glide\"]\nfile = res[\"genelist\"]\ndisease = file.split(\"/\")[-1]\nrwr_sorted = sorted(list(rwr), key=lambda x: x[1], reverse=True)\nglider_sorted = sorted(list(glider), key=lambda x: x[1], reverse=True)\nwith open(f\"./{disease}_glider\", \"w\") as f:\n    for gene, score in glider_sorted:\n        f.write(f\"{gene.name}\\t{score}\\n\")",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "rwr",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "rwr = res[\"rwr\"]\nglider = res[\"glide\"]\nfile = res[\"genelist\"]\ndisease = file.split(\"/\")[-1]\nrwr_sorted = sorted(list(rwr), key=lambda x: x[1], reverse=True)\nglider_sorted = sorted(list(glider), key=lambda x: x[1], reverse=True)\nwith open(f\"./{disease}_glider\", \"w\") as f:\n    for gene, score in glider_sorted:\n        f.write(f\"{gene.name}\\t{score}\\n\")\nwith open(f\"./{disease}_rwr\", \"w\") as f:",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "glider",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "glider = res[\"glide\"]\nfile = res[\"genelist\"]\ndisease = file.split(\"/\")[-1]\nrwr_sorted = sorted(list(rwr), key=lambda x: x[1], reverse=True)\nglider_sorted = sorted(list(glider), key=lambda x: x[1], reverse=True)\nwith open(f\"./{disease}_glider\", \"w\") as f:\n    for gene, score in glider_sorted:\n        f.write(f\"{gene.name}\\t{score}\\n\")\nwith open(f\"./{disease}_rwr\", \"w\") as f:\n    for gene, score in rwr_sorted:",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "file",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "file = res[\"genelist\"]\ndisease = file.split(\"/\")[-1]\nrwr_sorted = sorted(list(rwr), key=lambda x: x[1], reverse=True)\nglider_sorted = sorted(list(glider), key=lambda x: x[1], reverse=True)\nwith open(f\"./{disease}_glider\", \"w\") as f:\n    for gene, score in glider_sorted:\n        f.write(f\"{gene.name}\\t{score}\\n\")\nwith open(f\"./{disease}_rwr\", \"w\") as f:\n    for gene, score in rwr_sorted:\n        f.write(f\"{gene.name}\\t{score}\\n\")",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "disease",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "disease = file.split(\"/\")[-1]\nrwr_sorted = sorted(list(rwr), key=lambda x: x[1], reverse=True)\nglider_sorted = sorted(list(glider), key=lambda x: x[1], reverse=True)\nwith open(f\"./{disease}_glider\", \"w\") as f:\n    for gene, score in glider_sorted:\n        f.write(f\"{gene.name}\\t{score}\\n\")\nwith open(f\"./{disease}_rwr\", \"w\") as f:\n    for gene, score in rwr_sorted:\n        f.write(f\"{gene.name}\\t{score}\\n\")\nrwr_250 = rwr_sorted[:250]",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "rwr_sorted",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "rwr_sorted = sorted(list(rwr), key=lambda x: x[1], reverse=True)\nglider_sorted = sorted(list(glider), key=lambda x: x[1], reverse=True)\nwith open(f\"./{disease}_glider\", \"w\") as f:\n    for gene, score in glider_sorted:\n        f.write(f\"{gene.name}\\t{score}\\n\")\nwith open(f\"./{disease}_rwr\", \"w\") as f:\n    for gene, score in rwr_sorted:\n        f.write(f\"{gene.name}\\t{score}\\n\")\nrwr_250 = rwr_sorted[:250]\nglider_250 = glider_sorted[:250]",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "glider_sorted",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "glider_sorted = sorted(list(glider), key=lambda x: x[1], reverse=True)\nwith open(f\"./{disease}_glider\", \"w\") as f:\n    for gene, score in glider_sorted:\n        f.write(f\"{gene.name}\\t{score}\\n\")\nwith open(f\"./{disease}_rwr\", \"w\") as f:\n    for gene, score in rwr_sorted:\n        f.write(f\"{gene.name}\\t{score}\\n\")\nrwr_250 = rwr_sorted[:250]\nglider_250 = glider_sorted[:250]\nglider_names_only = set([g[0].name for g in glider_250])",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "rwr_250",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "rwr_250 = rwr_sorted[:250]\nglider_250 = glider_sorted[:250]\nglider_names_only = set([g[0].name for g in glider_250])\nrwr_names_only = set([g[0].name for g in rwr_250])\ndiff = glider_names_only - rwr_names_only\ndiff_with_score = sorted(\n    [g for g in glider_250 if g[0].name in diff], key=lambda x: x[1], reverse=True)\nwith open(f\"./{disease}_diff\", \"w\") as f:\n    for gene, score in diff_with_score:\n        f.write(f\"{gene.name}\\t{score}\\n\")",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "glider_250",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "glider_250 = glider_sorted[:250]\nglider_names_only = set([g[0].name for g in glider_250])\nrwr_names_only = set([g[0].name for g in rwr_250])\ndiff = glider_names_only - rwr_names_only\ndiff_with_score = sorted(\n    [g for g in glider_250 if g[0].name in diff], key=lambda x: x[1], reverse=True)\nwith open(f\"./{disease}_diff\", \"w\") as f:\n    for gene, score in diff_with_score:\n        f.write(f\"{gene.name}\\t{score}\\n\")",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "glider_names_only",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "glider_names_only = set([g[0].name for g in glider_250])\nrwr_names_only = set([g[0].name for g in rwr_250])\ndiff = glider_names_only - rwr_names_only\ndiff_with_score = sorted(\n    [g for g in glider_250 if g[0].name in diff], key=lambda x: x[1], reverse=True)\nwith open(f\"./{disease}_diff\", \"w\") as f:\n    for gene, score in diff_with_score:\n        f.write(f\"{gene.name}\\t{score}\\n\")",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "rwr_names_only",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "rwr_names_only = set([g[0].name for g in rwr_250])\ndiff = glider_names_only - rwr_names_only\ndiff_with_score = sorted(\n    [g for g in glider_250 if g[0].name in diff], key=lambda x: x[1], reverse=True)\nwith open(f\"./{disease}_diff\", \"w\") as f:\n    for gene, score in diff_with_score:\n        f.write(f\"{gene.name}\\t{score}\\n\")",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "diff",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "diff = glider_names_only - rwr_names_only\ndiff_with_score = sorted(\n    [g for g in glider_250 if g[0].name in diff], key=lambda x: x[1], reverse=True)\nwith open(f\"./{disease}_diff\", \"w\") as f:\n    for gene, score in diff_with_score:\n        f.write(f\"{gene.name}\\t{score}\\n\")",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "diff_with_score",
        "kind": 5,
        "importPath": "notebooks.get-genelist",
        "description": "notebooks.get-genelist",
        "peekOfCode": "diff_with_score = sorted(\n    [g for g in glider_250 if g[0].name in diff], key=lambda x: x[1], reverse=True)\nwith open(f\"./{disease}_diff\", \"w\") as f:\n    for gene, score in diff_with_score:\n        f.write(f\"{gene.name}\\t{score}\\n\")",
        "detail": "notebooks.get-genelist",
        "documentation": {}
    },
    {
        "label": "inv_square",
        "kind": 2,
        "importPath": "scripts.argument_parsing",
        "description": "scripts.argument_parsing",
        "peekOfCode": "def inv_square(x: float) -> float:\n    return 1.0 / (x * x)\nwith open(\"file\", \"r\") as f:\n    lines = f.readlines()\nf = open(\"file\", \"r\")\nlines = f.readlines()\nf.close()",
        "detail": "scripts.argument_parsing",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "scripts.argument_parsing",
        "description": "scripts.argument_parsing",
        "peekOfCode": "parser = argparse.ArgumentParser()\nparser.add_argument(\"-f\", \"--file\", help=\"The name of the file to read in.\")\nparser.add_argument(\"-o\", \"--output\", help=\"The name of the file to write to.\")\nparser.add_argument(\"-t\", \"--type\", help=\"The type of the file.\")\n# Fast inverse square.\ndef inv_square(x: float) -> float:\n    return 1.0 / (x * x)\nwith open(\"file\", \"r\") as f:\n    lines = f.readlines()\nf = open(\"file\", \"r\")",
        "detail": "scripts.argument_parsing",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "scripts.argument_parsing",
        "description": "scripts.argument_parsing",
        "peekOfCode": "f = open(\"file\", \"r\")\nlines = f.readlines()\nf.close()",
        "detail": "scripts.argument_parsing",
        "documentation": {}
    },
    {
        "label": "lines",
        "kind": 5,
        "importPath": "scripts.argument_parsing",
        "description": "scripts.argument_parsing",
        "peekOfCode": "lines = f.readlines()\nf.close()",
        "detail": "scripts.argument_parsing",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.glider_experiments",
        "description": "scripts.glider_experiments",
        "peekOfCode": "def main(args: argparse.Namespace):\n    # Using glob get all of the tissue files.\n    tissue_files = glob.glob(args.tissue_path + '/*.tsv')\n    model = Glider(lamb=args.lamb, glide_beta = args.beta)\n    for tissue_file in tissue_files:\n        huri = Huri(args.gene_set, with_hugo=True)\n        stringdb = StringDB(args.gene_set)\n        merged = merge([huri, stringdb])\n        if isinstance(model, PreComputeFeta):\n\t        model.setup(merged.graph)",
        "detail": "scripts.glider_experiments",
        "documentation": {}
    },
    {
        "label": "save_results",
        "kind": 2,
        "importPath": "scripts.glider_experiments",
        "description": "scripts.glider_experiments",
        "peekOfCode": "def save_results(true_pos: list[float], false_pos: list[float], file_name: str) -> None:\n    with open(file_name, \"w\") as f:\n        true_pos_str = \",\".join(map(str, true_pos))\n        false_pos_str = \",\".join(map(str, false_pos))\n        f.write(f\"TP:\\t({true_pos_str})\\n\")\n        f.write(f\"FP:\\t({false_pos_str})\\n\")\nif __name__ == '__main__':\n    args = parser.parse_args()\n    main(args)",
        "detail": "scripts.glider_experiments",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "scripts.glider_experiments",
        "description": "scripts.glider_experiments",
        "peekOfCode": "parser = argparse.ArgumentParser(description='Tissue reweight by algs')\nparser.add_argument('-t', '--tissue-path', type=str, required=True,\n                    help='Path to folder that contains tissue presence data')\nparser.add_argument('--lamb', type=float, default=1)\nparser.add_argument('--beta', type=float, default=1000)\nparser.add_argument('-g', '--gene-set', type=str,\n                    required=True, help=\"path to genesets\")\nparser.add_argument('-th', '--thresholds', type=list,\n                    default=[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\ndef main(args: argparse.Namespace):",
        "detail": "scripts.glider_experiments",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.tissue_reweight_by_algs_exp",
        "description": "scripts.tissue_reweight_by_algs_exp",
        "peekOfCode": "def main(args: argparse.Namespace):\n    # Using glob get all of the tissue files.\n    tissue_files = glob.glob(args.tissue_path + '/*.tsv')\n    if args.algorithms == 'all':\n        algs = ['rwr', 'glider', 'dada', 'glider+dada']\n    else:\n        algs = [args.algorithms]\n    for tissue_file in tissue_files:\n        huri = Huri(args.gene_set, with_hugo=True)\n        stringdb = StringDB(args.gene_set)",
        "detail": "scripts.tissue_reweight_by_algs_exp",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "scripts.tissue_reweight_by_algs_exp",
        "description": "scripts.tissue_reweight_by_algs_exp",
        "peekOfCode": "parser = argparse.ArgumentParser(description='Tissue reweight by algs')\nparser.add_argument('-t', '--tissue-path', type=str, required=True,\n                    help='Path to folder that contains tissue presence data')\nparser.add_argument('-a', '--algorithms',\n                    choices=['all', 'rwr', 'glider', 'dada', 'glider+dada'])\nparser.add_argument('-g', '--gene-set', type=str,\n                    required=True, help=\"path to genesets\")\nparser.add_argument('-th', '--thresholds', type=list,\n                    default=[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\nmodels = {",
        "detail": "scripts.tissue_reweight_by_algs_exp",
        "documentation": {}
    },
    {
        "label": "models",
        "kind": 5,
        "importPath": "scripts.tissue_reweight_by_algs_exp",
        "description": "scripts.tissue_reweight_by_algs_exp",
        "peekOfCode": "models = {\n    'rwr': RandomWalkWithRestart,\n    'glider': Glider,\n    'dada': Dada,\n    'glider+dada': lambda: Glider(with_dada=True)\n}\ndef main(args: argparse.Namespace):\n    # Using glob get all of the tissue files.\n    tissue_files = glob.glob(args.tissue_path + '/*.tsv')\n    if args.algorithms == 'all':",
        "detail": "scripts.tissue_reweight_by_algs_exp",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.visualize_glider_exp",
        "description": "scripts.visualize_glider_exp",
        "peekOfCode": "def main(args: argparse.Namespace):\n    # Results files will be all files in path ending in \".result\"\n    result_files = glob.glob(args.result_path + '/*.result')\n    # Plot data in each file\n    for result_file in result_files:\n        # First line: true positives\n        # Second line: false positives\n        with open(result_file) as file:\n           yvals = file.readline()\n           xvals = file.readline()",
        "detail": "scripts.visualize_glider_exp",
        "documentation": {}
    },
    {
        "label": "format_roc_vals",
        "kind": 2,
        "importPath": "scripts.visualize_glider_exp",
        "description": "scripts.visualize_glider_exp",
        "peekOfCode": "def format_roc_vals(roc_vals):\n    roc_vals = roc_vals[5:-2]\n    roc_vals = roc_vals.split(\",\")\n    for i in range(len(roc_vals)):\n        roc_vals[i] = float(roc_vals[i])\n    return roc_vals\ndef plot_roc(yvals, xvals):\n    plt.plot(xvals, yvals)\n    plt.xlabel(\"False Positive\")\n    plt.ylabel(\"True Positive\")",
        "detail": "scripts.visualize_glider_exp",
        "documentation": {}
    },
    {
        "label": "plot_roc",
        "kind": 2,
        "importPath": "scripts.visualize_glider_exp",
        "description": "scripts.visualize_glider_exp",
        "peekOfCode": "def plot_roc(yvals, xvals):\n    plt.plot(xvals, yvals)\n    plt.xlabel(\"False Positive\")\n    plt.ylabel(\"True Positive\")\n    plt.savefig('/cluster/tufts/cowenlab/mgelem01/E-MTAB-5214/GLIDER_Params_Experiment/glider_exp_results.jpg')\nif __name__ == '__main__':\n    args = parser.parse_args()\n    main(args)",
        "detail": "scripts.visualize_glider_exp",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "scripts.visualize_glider_exp",
        "description": "scripts.visualize_glider_exp",
        "peekOfCode": "parser = argparse.ArgumentParser(description='Visualize ROC results')\nparser.add_argument('-r', '--result-path', type=str, required=True,\n                    help='Path to folder that contains true/false positive data')\ndef main(args: argparse.Namespace):\n    # Results files will be all files in path ending in \".result\"\n    result_files = glob.glob(args.result_path + '/*.result')\n    # Plot data in each file\n    for result_file in result_files:\n        # First line: true positives\n        # Second line: false positives",
        "detail": "scripts.visualize_glider_exp",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.main",
        "description": "src.main",
        "peekOfCode": "def main(args: argparse.Namespace) -> None:\n\t...\nif __name__ == \"__main__\":\n    # create the top-level parser\n    parser = argparse.ArgumentParser(description=\"TMAP CLI\")\n    parser.add_argument('--model', type=str, choices=[\"glide\", \"rwr\"], required=True)\n    parser.add_argument('--disease_file', type=str, required=True)\n    parser.add_argument('--dataset', type=str, choices=[\"huri\", \"stringdb\"], required=True)\n    parser.add_argument('--cv', type=bool, default=False, action=argparse.BooleanOptionalAction)\n    parser.add_argument('--k', type=int, default=100)",
        "detail": "src.main",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "src.main",
        "description": "src.main",
        "peekOfCode": "args = parser.parse_args()\nprint(f\"{args}\")\nmain(args)",
        "detail": "src.main",
        "documentation": {}
    },
    {
        "label": "Dada",
        "kind": 6,
        "importPath": "t_map.feta.dada",
        "description": "t_map.feta.dada",
        "peekOfCode": "class Dada(Feta):\n    def __init__(self, alpha=0.85):\n        self._desc = Description(\n            requires_training=False,\n            training_opts=None,\n            hyper_params={\"alpha\": alpha})\n    def description(self) -> Description:\n        return self.__desc\n    def prioritize(self, disease_gene: List[Gene],\n                   graph: Union[nx.Graph, None], **kwargs) -> Set[Tuple[Gene, float]]:",
        "detail": "t_map.feta.dada",
        "documentation": {}
    },
    {
        "label": "Description",
        "kind": 6,
        "importPath": "t_map.feta.description",
        "description": "t_map.feta.description",
        "peekOfCode": "class Description:\n    requires_training: bool\n    training_opts: Any  # Hummus should know about TrainingOptions\n    hyper_params: Dict[str, Any]",
        "detail": "t_map.feta.description",
        "documentation": {}
    },
    {
        "label": "Feta",
        "kind": 6,
        "importPath": "t_map.feta.feta",
        "description": "t_map.feta.feta",
        "peekOfCode": "class Feta(ABC):\n    \"\"\"\n        Feta is the model which holds different methods of prioritization.\n        For any method there are three functions:\n            description: Returns a description of the model.\n            prioritize: Prioritizes a set of genes in a graph based\n                            on a prioritization algorithm\n                Parameters: Takes in a list of Genes\n                            Optional: a networkx Graph\n                Returns a set of tuples with the gene and float prioritization",
        "detail": "t_map.feta.feta",
        "documentation": {}
    },
    {
        "label": "PreComputeFeta",
        "kind": 6,
        "importPath": "t_map.feta.feta",
        "description": "t_map.feta.feta",
        "peekOfCode": "class PreComputeFeta(Feta):\n    \"\"\"\n        Within the Feta model there is also a subclass\n        for any method that requires precomputing which\n        requires an additional setup function.\n            setup: Does precomputing that prioritize needs for a given method\n                Parameters: a networkx Graph\n    \"\"\"\n    @abstractmethod\n    def setup(self, graph: nx.Graph, *args, **kwargs):",
        "detail": "t_map.feta.feta",
        "documentation": {}
    },
    {
        "label": "bcolors",
        "kind": 6,
        "importPath": "t_map.feta.glide",
        "description": "t_map.feta.glide",
        "peekOfCode": "class bcolors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKCYAN = '\\033[96m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'",
        "detail": "t_map.feta.glide",
        "documentation": {}
    },
    {
        "label": "ADAGIO",
        "kind": 6,
        "importPath": "t_map.feta.glide",
        "description": "t_map.feta.glide",
        "peekOfCode": "class ADAGIO(PreComputeFeta):\n    def __init__(self, is_annotated=True, lamb: int = 1,\n                 is_normalized: bool = False, glide_alph: float = 0.1,\n                 glide_delta: int = 1,\n                 with_dada: bool = False, dada_alpha: float = 0.85,\n                 glide_loc=\"cw_normalized\", extend_network: bool = False,\n                 per_node_new_edges_count: int = 0,\n                 global_new_edges_percentage: float = 0, **kwargs) -> None:\n        self.__desc = Description(requires_training=False, training_opts=False,\n                                  hyper_params={",
        "detail": "t_map.feta.glide",
        "documentation": {}
    },
    {
        "label": "RandomWalkWithRestart",
        "kind": 6,
        "importPath": "t_map.feta.randomwalk",
        "description": "t_map.feta.randomwalk",
        "peekOfCode": "class RandomWalkWithRestart(Feta):\n    def __init__(self, alpha=0.85):\n        self._desc = Description(\n            requires_training=False,\n            training_opts=None,\n            hyper_params={\"alpha\": alpha})\n    def description(self) -> Description:\n        return self.__desc\n    def prioritize(self, disease_gene: List[Gene],\n                   graph: Union[nx.Graph, None], **kwargs) -> Set[Tuple[Gene, float]]:",
        "detail": "t_map.feta.randomwalk",
        "documentation": {}
    },
    {
        "label": "PreComputeRWR",
        "kind": 6,
        "importPath": "t_map.feta.randomwalk",
        "description": "t_map.feta.randomwalk",
        "peekOfCode": "class PreComputeRWR(PreComputeFeta):\n    def __init__(self, alpha=0.85, **kwargs):\n        self.__desc = Description(\n            requires_training=False,\n            training_opts=None,\n            hyper_params={\"alpha\": alpha})\n    def description(self) -> Description:\n        return self.__desc\n    def prioritize(self, disease_gene: List[Gene],\n                   graph: Union[nx.Graph, None], **kwargs) -> Set[Tuple[Gene, float]]:     ",
        "detail": "t_map.feta.randomwalk",
        "documentation": {}
    },
    {
        "label": "gen_noise",
        "kind": 2,
        "importPath": "t_map.garbanzo.transforms.noise",
        "description": "t_map.garbanzo.transforms.noise",
        "peekOfCode": "def gen_noise(graph: nx.Graph, p: float = 0.05) -> nx.Graph:\n    \"\"\"\n    Generate noise on the graph.\n    :param graph:\n    :return:\n    # Given a percentage p of the edges to be added/removed in the network\n    # 1) If p is less than 0 (removal):-> preserve the maximum spanning tree. For the remaining edges not in the tree,\n    # sample from the uniform distribution $U$, for each edge in the network. If the u_{ij}\n    # sampled for edge (i, j) is less than p, then remove.\n    # If p is greater than 0 (addition) -> randomly generate [(p, q, w)] ",
        "detail": "t_map.garbanzo.transforms.noise",
        "documentation": {}
    },
    {
        "label": "reweight_graph_by_tissue",
        "kind": 2,
        "importPath": "t_map.garbanzo.transforms.tissue_reweight",
        "description": "t_map.garbanzo.transforms.tissue_reweight",
        "peekOfCode": "def reweight_graph_by_tissue(graph: nx.Graph,\n                             file_path: str,\n                             weight: float = 0.001,\n                             getter: Optional[Callable[[str], Tuple[str, int]]] = None) -> nx.Graph:\n    \"\"\"\n    Given a network `graph` of ppi interactions, and a file path to containing data\n    as to where or not a gene is expressed in a given tissue:\n        ENSEMBL_ID   Gene\t[0-1]\n    where 0 indicates low expression and 1 indicates high expression. The function\n    reweights the graph by multiplying the weight of each edge by w' = w * weight^{2 - n}",
        "detail": "t_map.garbanzo.transforms.tissue_reweight",
        "documentation": {}
    },
    {
        "label": "EdgeListGarbanzo",
        "kind": 6,
        "importPath": "t_map.garbanzo.edgelist",
        "description": "t_map.garbanzo.edgelist",
        "peekOfCode": "class EdgeListGarbanzo(Garbanzo):\n    def __init__(self, graph_path: str, gene_path: str):\n        self._graph_path = graph_path\n        self._gene_path = gene_path\n        self._graph = self._read_graph_from_path(graph_path)\n        self._genes = self._read_genes_from_path(gene_path)\n    @property\n    def graph(self) -> nx.Graph:\n        return self._graph\n    @property",
        "detail": "t_map.garbanzo.edgelist",
        "documentation": {}
    },
    {
        "label": "Garbanzo",
        "kind": 6,
        "importPath": "t_map.garbanzo.garbanzo",
        "description": "t_map.garbanzo.garbanzo",
        "peekOfCode": "class Garbanzo(ABC):\n    @abstractproperty\n    def graph(self) -> nx.Graph:\n        ...\n    @abstractproperty\n    def graph_path(self) -> str:\n        ...\n    @abstractproperty\n    def gene_path(self) -> str:\n        ...",
        "detail": "t_map.garbanzo.garbanzo",
        "documentation": {}
    },
    {
        "label": "Huri",
        "kind": 6,
        "importPath": "t_map.garbanzo.huri",
        "description": "t_map.garbanzo.huri",
        "peekOfCode": "class Huri(EdgeListGarbanzo):\n    HURI_URL = \"https://bcb.cs.tufts.edu/huri/huri.tsv\"\n    HURI_HUGO = \"https://bcb.cs.tufts.edu/huri/huri_hgnc.tsv\"\n    def __init__(self, gene_path: str, download_path: str = \"/tmp/\",\n                 with_hugo: bool = False):\n        self._gene_path = gene_path\n        self._with_hugo = with_hugo\n        self._graph_pathlib: pathlib.Path = pathlib.Path(\n            download_path) / \"huri\"\n        self._graph = self._download_and_parse_graph()",
        "detail": "t_map.garbanzo.huri",
        "documentation": {}
    },
    {
        "label": "MergedGarbanzo",
        "kind": 6,
        "importPath": "t_map.garbanzo.merge",
        "description": "t_map.garbanzo.merge",
        "peekOfCode": "class MergedGarbanzo(Garbanzo):\n    def __init__(self, graph: nx.Graph, genes: List[Gene]):\n        self._graph = graph\n        self._genes = genes\n    @property\n    def graph(self) -> nx.Graph:\n        return self._graph\n    @property\n    def graph_path(self) -> str:\n        raise Exception(\"Merged Graphs Do Not Have a graph path\")",
        "detail": "t_map.garbanzo.merge",
        "documentation": {}
    },
    {
        "label": "add_weights",
        "kind": 2,
        "importPath": "t_map.garbanzo.merge",
        "description": "t_map.garbanzo.merge",
        "peekOfCode": "def add_weights(data: Garbanzo) -> Garbanzo:\n    \"\"\"\n    Adds weight 1 to all edges in a graph.\n    :param graph:\n    :return: A graph with weights 1.\n    \"\"\"\n    for u, v in data.graph.edges():\n        data.graph[u][v]['weight'] = 1\n    return data\ndef normalize(data: Garbanzo) -> Garbanzo:",
        "detail": "t_map.garbanzo.merge",
        "documentation": {}
    },
    {
        "label": "normalize",
        "kind": 2,
        "importPath": "t_map.garbanzo.merge",
        "description": "t_map.garbanzo.merge",
        "peekOfCode": "def normalize(data: Garbanzo) -> Garbanzo:\n    \"\"\"\n    Given a graph, normalizes the weights of the edges \n    by the maximum edge weight.\n    \"\"\"\n    max_weight = max(data.graph.edges(data='weight'), key=lambda x: x[2])[2]\n    print(max_weight)\n    for u, v in data.graph.edges():\n        data.graph[u][v]['weight'] = data.graph[u][v]['weight'] / max_weight\n    return data",
        "detail": "t_map.garbanzo.merge",
        "documentation": {}
    },
    {
        "label": "merge",
        "kind": 2,
        "importPath": "t_map.garbanzo.merge",
        "description": "t_map.garbanzo.merge",
        "peekOfCode": "def merge(items: Iterable[Union[Garbanzo, nx.Graph]]) -> Garbanzo:\n    if not any([isinstance(item, Garbanzo) for item in items]):\n        raise Exception(\"At least one item needs to be of instance Garbanzo\")\n    if any([nx.is_weighted(item.graph) for item in items]):\n        weighted_networks = [\n            item for item in items if nx.is_weighted(item.graph)]\n        unweighted_networks = [\n            item for item in items if not nx.is_weighted(item.graph)]\n        reweighted_networks = [add_weights(item)\n                               for item in unweighted_networks]",
        "detail": "t_map.garbanzo.merge",
        "documentation": {}
    },
    {
        "label": "Networkx",
        "kind": 6,
        "importPath": "t_map.garbanzo.networkx",
        "description": "t_map.garbanzo.networkx",
        "peekOfCode": "class Networkx(Garbanzo):\n    def __init__(self, graph: nx.Graph, genes: Optional[List[Gene]] = None):\n        self._graph = graph\n        self._genes = genes if genes is not None else []\n    @property\n    def graph(self) -> nx.Graph:\n        return self._graph\n    @property\n    def genes(self) -> List[Gene]:\n        return self._genes",
        "detail": "t_map.garbanzo.networkx",
        "documentation": {}
    },
    {
        "label": "StringDB",
        "kind": 6,
        "importPath": "t_map.garbanzo.stringdb",
        "description": "t_map.garbanzo.stringdb",
        "peekOfCode": "class StringDB(EdgeListGarbanzo):\n    STRING_URL = \"https://bcb.cs.tufts.edu/string_db/string_links.csv\"\n    def __init__(self, gene_path: str, download_path: str = \"/tmp/\"):\n        self._gene_path = gene_path\n        self._graph_pathlib: pathlib.Path = pathlib.Path(\n            download_path) / \"string_db\"\n        self._graph = self._download_and_parse_graph()\n        self._genes = self._read_genes_from_path(gene_path)\n    @property\n    def graph_path(self) -> str:",
        "detail": "t_map.garbanzo.stringdb",
        "documentation": {}
    },
    {
        "label": "Gene",
        "kind": 6,
        "importPath": "t_map.gene.gene",
        "description": "t_map.gene.gene",
        "peekOfCode": "class Gene:\n    name: str\n    labels: Union[List[str], None] = None",
        "detail": "t_map.gene.gene",
        "documentation": {}
    },
    {
        "label": "Hummus",
        "kind": 6,
        "importPath": "t_map.hummus.hummus",
        "description": "t_map.hummus.hummus",
        "peekOfCode": "class Hummus:\n    def __init__(self, data: Garbanzo,\n                 with_scoring: Optional[HummusScore] = None,\n                 train_test_split_ratio: Optional[float] = None):\n        self.data = data\n        self._genes = [self.data.get(i) for i in range(len(data))]\n        self._score_module = with_scoring\n        self._with_cv = False\n        self._train_test_split_ratio = train_test_split_ratio\n    def with_cv(self, k_fold: Union[int, Literal[\"LOO\"]] = 5) -> Hummus:",
        "detail": "t_map.hummus.hummus",
        "documentation": {}
    },
    {
        "label": "HummusTester",
        "kind": 6,
        "importPath": "t_map.hummus.hummus",
        "description": "t_map.hummus.hummus",
        "peekOfCode": "class HummusTester(ContextManager):\n    def __init__(self, data: Garbanzo, test_idx: List[int],\n                 with_scoring: Union[None,\n                                     HummusScore] = None):\n        self._data: Garbanzo = data\n        self._test: List[int] = test_idx\n        self._i = 0\n        self._heldout_genes = self._collect_heldout_genes()\n        self._with_scoring = with_scoring\n        if self._with_scoring is not None:",
        "detail": "t_map.hummus.hummus",
        "documentation": {}
    },
    {
        "label": "HummusTrainer",
        "kind": 6,
        "importPath": "t_map.hummus.hummus",
        "description": "t_map.hummus.hummus",
        "peekOfCode": "class HummusTrainer(ContextManager):\n    \"\"\"\n        Ideally I expect this to be a training class, but\n        after much thought I am a bit puzzled as to how to\n        best structure this.\n    \"\"\"\n    def __init__(self, data: Garbanzo, train_idx: List[int],\n                 with_scoring: Union[None,\n                                     HummusScore] = None):\n        self._data: Garbanzo = data",
        "detail": "t_map.hummus.hummus",
        "documentation": {}
    },
    {
        "label": "KnownGenes",
        "kind": 5,
        "importPath": "t_map.hummus.hummus",
        "description": "t_map.hummus.hummus",
        "peekOfCode": "KnownGenes = List[Gene]\nHeldoutGenes = List[Gene]\nclass Hummus:\n    def __init__(self, data: Garbanzo,\n                 with_scoring: Optional[HummusScore] = None,\n                 train_test_split_ratio: Optional[float] = None):\n        self.data = data\n        self._genes = [self.data.get(i) for i in range(len(data))]\n        self._score_module = with_scoring\n        self._with_cv = False",
        "detail": "t_map.hummus.hummus",
        "documentation": {}
    },
    {
        "label": "HeldoutGenes",
        "kind": 5,
        "importPath": "t_map.hummus.hummus",
        "description": "t_map.hummus.hummus",
        "peekOfCode": "HeldoutGenes = List[Gene]\nclass Hummus:\n    def __init__(self, data: Garbanzo,\n                 with_scoring: Optional[HummusScore] = None,\n                 train_test_split_ratio: Optional[float] = None):\n        self.data = data\n        self._genes = [self.data.get(i) for i in range(len(data))]\n        self._score_module = with_scoring\n        self._with_cv = False\n        self._train_test_split_ratio = train_test_split_ratio",
        "detail": "t_map.hummus.hummus",
        "documentation": {}
    },
    {
        "label": "ScoreTypes",
        "kind": 6,
        "importPath": "t_map.hummus.hummus_score",
        "description": "t_map.hummus.hummus_score",
        "peekOfCode": "class ScoreTypes(Enum):\n    TOP_K = auto()\nclass HummusScore:\n    \"\"\"Hummus Score is a module used for scoring a particular\n    prioritization algorithm. Its main purpose is to be passed\n    into an instance of Hummus to the `with_scoring` parameter.\n    If provided during testing and training time, the Hummus\n    module with additionally return a score function, which will\n    accept a list of prediction with or without a score.\n    Note: Hummus Score function returns None. It is the responsibility",
        "detail": "t_map.hummus.hummus_score",
        "documentation": {}
    },
    {
        "label": "HummusScore",
        "kind": 6,
        "importPath": "t_map.hummus.hummus_score",
        "description": "t_map.hummus.hummus_score",
        "peekOfCode": "class HummusScore:\n    \"\"\"Hummus Score is a module used for scoring a particular\n    prioritization algorithm. Its main purpose is to be passed\n    into an instance of Hummus to the `with_scoring` parameter.\n    If provided during testing and training time, the Hummus\n    module with additionally return a score function, which will\n    accept a list of prediction with or without a score.\n    Note: Hummus Score function returns None. It is the responsibility\n    of Hummus Score to later provide results.\n    \"\"\"",
        "detail": "t_map.hummus.hummus_score",
        "documentation": {}
    },
    {
        "label": "roc_of_ranked_list",
        "kind": 2,
        "importPath": "t_map.hummus.hummus_score",
        "description": "t_map.hummus.hummus_score",
        "peekOfCode": "def roc_of_ranked_list(ranked_predictions: List[List[Gene]],\n                       target: List[List[Gene]],\n                       num_intervals: int = 20) -> List[Tuple[float, float]]:\n    \"\"\"\n    Given an ordered list of ranked predictions and a target list,\n    for each interval in the list, calculate the ROC score.\n    Args:\n        ranked_predictions: A list of ranked predictions\n        target: A list of ground truth\n        intervals: A list of intervals to calculate ROC scores",
        "detail": "t_map.hummus.hummus_score",
        "documentation": {}
    },
    {
        "label": "roc_score",
        "kind": 2,
        "importPath": "t_map.hummus.hummus_score",
        "description": "t_map.hummus.hummus_score",
        "peekOfCode": "def roc_score(ranked_predictions: List[List[Gene]],\n              target: List[List[Gene]],\n              end_range: int) -> Tuple[float, float]:\n    \"\"\"\n    Given a ranked list of predictions and a target list,\n    calculate the true positive rate and false positive rate.\n    Args:\n        ranked_predictions: A list of ranked predictions\n        target: A list of ground truth\n    Returns:",
        "detail": "t_map.hummus.hummus_score",
        "documentation": {}
    },
    {
        "label": "auc_from_fpr_tpr",
        "kind": 2,
        "importPath": "t_map.hummus.hummus_score",
        "description": "t_map.hummus.hummus_score",
        "peekOfCode": "def auc_from_fpr_tpr(fpr: List[float], tpr: List[float],\n                     trapezoid: bool = False) -> float:\n    import numpy as np\n    fpr = np.array(fpr)\n    tpr = np.array(tpr)\n    inds = [i for (i, (s, e)) in enumerate(\n        zip(fpr[: -1], fpr[1:])) if s != e] + [len(fpr) - 1]\n    fpr, tpr = fpr[inds], tpr[inds]\n    area = 0\n    ft = list(zip(fpr, tpr))",
        "detail": "t_map.hummus.hummus_score",
        "documentation": {}
    },
    {
        "label": "get_fpr_tpr_for_thresh",
        "kind": 2,
        "importPath": "t_map.hummus.hummus_score",
        "description": "t_map.hummus.hummus_score",
        "peekOfCode": "def get_fpr_tpr_for_thresh(fpr: List[float],\n                           tpr: List[float],\n                           thresh: float) -> Tuple[List[float], List[float]]:\n    import bisect\n    p = bisect.bisect_left(fpr, thresh)\n    assert p < len(fpr), f\"Attempted to bisect_left on value {thresh=} in {fpr=} that yielded an index {p=} out of bounds\"\n    fpr = fpr.copy()\n    fpr[p] = thresh\n    return fpr[: p + 1], tpr[: p + 1]",
        "detail": "t_map.hummus.hummus_score",
        "documentation": {}
    },
    {
        "label": "ScoreFn",
        "kind": 5,
        "importPath": "t_map.hummus.hummus_score",
        "description": "t_map.hummus.hummus_score",
        "peekOfCode": "ScoreFn = Callable[[Union[List[Gene], List[Tuple[Gene, float]]]], None]\nclass ScoreTypes(Enum):\n    TOP_K = auto()\nclass HummusScore:\n    \"\"\"Hummus Score is a module used for scoring a particular\n    prioritization algorithm. Its main purpose is to be passed\n    into an instance of Hummus to the `with_scoring` parameter.\n    If provided during testing and training time, the Hummus\n    module with additionally return a score function, which will\n    accept a list of prediction with or without a score.",
        "detail": "t_map.hummus.hummus_score",
        "documentation": {}
    },
    {
        "label": "Genedise",
        "kind": 6,
        "importPath": "t_map.t_map.glide_runner",
        "description": "t_map.t_map.glide_runner",
        "peekOfCode": "class Genedise(Garbanzo):\n    def __init__(self, graph_path, disease_path):\n        self._graph_path = graph_path\n        self._graph = nx.read_graphml(self._graph_path)\n        self.disease_path = disease_path\n        self._genes = []\n        with open(disease_path) as f:\n            for line in f:\n                self._genes.append(Gene(line.strip()))\n    @property",
        "detail": "t_map.t_map.glide_runner",
        "documentation": {}
    },
    {
        "label": "run_glide",
        "kind": 2,
        "importPath": "t_map.t_map.glide_runner",
        "description": "t_map.t_map.glide_runner",
        "peekOfCode": "def run_glide(graph_path, disease_path):\n    model = Glider()\n    data = Genedise(graph_path, disease_path)\n    model.setup(data.graph)\n    return model.prioritize(data.genes)",
        "detail": "t_map.t_map.glide_runner",
        "documentation": {}
    },
    {
        "label": "Split",
        "kind": 6,
        "importPath": "t_map.utils.genedise_utils",
        "description": "t_map.utils.genedise_utils",
        "peekOfCode": "class Split:\n    rep: int\n    disease_name: str\n    data_type: CLS_TYPE\n    training_folds: List[str]\n    validation_folds: List[str]\ndef run_genedise(graph_path: str,\n                 splits_path: str,\n                 output_path: str,\n                 model: Union[type[Union[Feta, PreComputeFeta]],",
        "detail": "t_map.utils.genedise_utils",
        "documentation": {}
    },
    {
        "label": "run_genedise",
        "kind": 2,
        "importPath": "t_map.utils.genedise_utils",
        "description": "t_map.utils.genedise_utils",
        "peekOfCode": "def run_genedise(graph_path: str,\n                 splits_path: str,\n                 output_path: str,\n                 model: Union[type[Union[Feta, PreComputeFeta]],\n                              Feta,\n                              PreComputeFeta],\n                 pickle_path: Optional[str] = None,\n                 variant: str=\"none\") -> None:\n    graph = load_graph(graph_path)\n#     graph = reweight_graph_by_tissue(",
        "detail": "t_map.utils.genedise_utils",
        "documentation": {}
    },
    {
        "label": "getter",
        "kind": 2,
        "importPath": "t_map.utils.genedise_utils",
        "description": "t_map.utils.genedise_utils",
        "peekOfCode": "def getter(string: str):\n    name, _, is_expressed = string.split(\"\\t\")\n    return name, int(is_expressed)\ndef run_split(split: Split, graph: nx.Graph,\n              model: Union[type[Union[Feta, PreComputeFeta]],\n                           Feta,\n                           PreComputeFeta],\n              output_path: str,\n              pickle_path: Optional[str] = None,\n              variant:str=\"none\") -> None:",
        "detail": "t_map.utils.genedise_utils",
        "documentation": {}
    },
    {
        "label": "run_split",
        "kind": 2,
        "importPath": "t_map.utils.genedise_utils",
        "description": "t_map.utils.genedise_utils",
        "peekOfCode": "def run_split(split: Split, graph: nx.Graph,\n              model: Union[type[Union[Feta, PreComputeFeta]],\n                           Feta,\n                           PreComputeFeta],\n              output_path: str,\n              pickle_path: Optional[str] = None,\n              variant:str=\"none\") -> None:\n    needs_to_load_pickle = pickle_path is not None\n    training_folds = split.training_folds\n    validation_folds = split.validation_folds",
        "detail": "t_map.utils.genedise_utils",
        "documentation": {}
    },
    {
        "label": "output_results",
        "kind": 2,
        "importPath": "t_map.utils.genedise_utils",
        "description": "t_map.utils.genedise_utils",
        "peekOfCode": "def output_results(results: List[List[Tuple[Gene, float]]],\n                   out_path: str) -> None:\n    import itertools\n    results = itertools.chain.from_iterable(results)\n    Path(out_path).parent.mkdir(parents=True, exist_ok=True)\n    with open(out_path, \"w\") as f:\n        for (gene, score) in results:\n            f.write(f\"{gene.name},{score}\\n\")\ndef read_genelist(path: str) -> List[Gene]:\n    df = pd.read_csv(path, sep=\",\", skiprows=1, names=[\"gene\", \"is_disease\"])",
        "detail": "t_map.utils.genedise_utils",
        "documentation": {}
    },
    {
        "label": "read_genelist",
        "kind": 2,
        "importPath": "t_map.utils.genedise_utils",
        "description": "t_map.utils.genedise_utils",
        "peekOfCode": "def read_genelist(path: str) -> List[Gene]:\n    df = pd.read_csv(path, sep=\",\", skiprows=1, names=[\"gene\", \"is_disease\"])\n    df = df[df[\"is_disease\"] == 1]\n    gene_list = [Gene(g) for g in df[\"gene\"].tolist()]\n    return gene_list\ndef restructure_splits(splits: List[str], splits_path: str) -> Dict[int, List[Split]]:\n    rep_to_files = defaultdict(list)\n    rep_to_split = dict()\n    prefix = splits_path + \"/\"\n    for split in splits:",
        "detail": "t_map.utils.genedise_utils",
        "documentation": {}
    },
    {
        "label": "restructure_splits",
        "kind": 2,
        "importPath": "t_map.utils.genedise_utils",
        "description": "t_map.utils.genedise_utils",
        "peekOfCode": "def restructure_splits(splits: List[str], splits_path: str) -> Dict[int, List[Split]]:\n    rep_to_files = defaultdict(list)\n    rep_to_split = dict()\n    prefix = splits_path + \"/\"\n    for split in splits:\n        rep = split.removeprefix(prefix).split(\".\")[0]\n        rep_to_files[rep].append(split)\n    for rep in rep_to_files.keys():\n        files = rep_to_files[rep]\n        validation_fold = [f for f in files if \"_val\" in f]",
        "detail": "t_map.utils.genedise_utils",
        "documentation": {}
    },
    {
        "label": "generate_split_for_fold",
        "kind": 2,
        "importPath": "t_map.utils.genedise_utils",
        "description": "t_map.utils.genedise_utils",
        "peekOfCode": "def generate_split_for_fold(fold: int, validation_fold: List[str],\n                            training_fold: List[str], prefix: str) -> List[Split]:\n    # A dictionary that takes the type of the split\n    # and returns a tuple of training and validation folds\n    ty = Dict[CLS_TYPE, Tuple[List[str], List[str]]]\n    disease_to_data_type_to_fold: ty = dict()\n    for tf, vf in zip(sorted(training_fold), sorted(validation_fold)):\n        _, disease_name, disease_type, *_ = tf.removeprefix(prefix).split(\"_\")\n        if disease_type not in disease_to_data_type_to_fold:\n            disease_to_data_type_to_fold[disease_type] = dict()",
        "detail": "t_map.utils.genedise_utils",
        "documentation": {}
    },
    {
        "label": "load_and_relabel_graph",
        "kind": 2,
        "importPath": "t_map.utils.genedise_utils",
        "description": "t_map.utils.genedise_utils",
        "peekOfCode": "def load_and_relabel_graph(path: str) -> nx.Graph:\n    graph = nx.read_graphml(path)\n    relabeling_dict = dict()\n    for node, data in graph.nodes(data=True):\n        relabeling_dict[node] = data[\"name\"]\n    graph = nx.relabel_nodes(graph, relabeling_dict)\n    return graph\ndef load_graph(path: str) -> nx.Graph:\n    # load tab seperated edge list from path\n    edge_list = pd.read_csv(path, sep=\"\\t\")",
        "detail": "t_map.utils.genedise_utils",
        "documentation": {}
    },
    {
        "label": "load_graph",
        "kind": 2,
        "importPath": "t_map.utils.genedise_utils",
        "description": "t_map.utils.genedise_utils",
        "peekOfCode": "def load_graph(path: str) -> nx.Graph:\n    # load tab seperated edge list from path\n    edge_list = pd.read_csv(path, sep=\"\\t\")\n    # convert pandas dataframe to networkx graph\n    graph = nx.from_pandas_edgelist(\n        edge_list, source=\"src\", target=\"dst\", edge_attr=True)\n    return graph",
        "detail": "t_map.utils.genedise_utils",
        "documentation": {}
    },
    {
        "label": "CLS_TYPE",
        "kind": 5,
        "importPath": "t_map.utils.genedise_utils",
        "description": "t_map.utils.genedise_utils",
        "peekOfCode": "CLS_TYPE = Union[Literal[\"genetic\"], Literal[\"drugs\"]]\n@dataclass\nclass Split:\n    rep: int\n    disease_name: str\n    data_type: CLS_TYPE\n    training_folds: List[str]\n    validation_folds: List[str]\ndef run_genedise(graph_path: str,\n                 splits_path: str,",
        "detail": "t_map.utils.genedise_utils",
        "documentation": {}
    },
    {
        "label": "Witness",
        "kind": 6,
        "importPath": "t_map.utils.interval_of_witness",
        "description": "t_map.utils.interval_of_witness",
        "peekOfCode": "class Witness:\n    def __init__(self, l_1: List[Tuple[Gene, float]],\n                 *args: List[Tuple[Gene, float]]):\n        self.l_1 = l_1\n        self.l_2s = args\n        self.l_1_map = dict()\n        self.l_2_map = defaultdict(list)\n        for i, (g, _) in enumerate(l_1):\n            self.l_1_map[g.name] = i\n        for l in self.l_2s:",
        "detail": "t_map.utils.interval_of_witness",
        "documentation": {}
    },
    {
        "label": "test_rwr",
        "kind": 2,
        "importPath": "tests.test_feta",
        "description": "tests.test_feta",
        "peekOfCode": "def test_rwr():\n    data = EdgeListGarbanzo(\n        graph_path=\"./tests/data/unweighted_edge.list\",\n        gene_path=\"./tests/data/gene.list\")\n    model = RandomWalkWithRestart()\n    model(data.get(0), data.graph)\n    model([data.get(0), data.get(1)], data.graph)\n    precompute = PreComputeRWR()\n    precompute(data.get(0), data.graph)\n    precompute([data.get(0), data.get(3)], data.graph)",
        "detail": "tests.test_feta",
        "documentation": {}
    },
    {
        "label": "test_glider",
        "kind": 2,
        "importPath": "tests.test_feta",
        "description": "tests.test_feta",
        "peekOfCode": "def test_glider():\n    TISSUE_PATH = \"/cluster/tufts/cowenlab/mgelem01/E-MTAB-5214/tissue_files\" + \"/*.tsv\"\n    data = EdgeListGarbanzo(\n        graph_path=\"./tests/data/unweighted_edge.list\",\n        gene_path=\"./tests/data/gene.list\")\n    import glob\n    tissue_file = glob.glob(TISSUE_PATH)[0]\n    print(tissue_file)\n    model = Glider()\n    model.setup(data.graph)",
        "detail": "tests.test_feta",
        "documentation": {}
    },
    {
        "label": "test_edgelist",
        "kind": 2,
        "importPath": "tests.test_garbanzo",
        "description": "tests.test_garbanzo",
        "peekOfCode": "def test_edgelist():\n    # testing for side effect\n    EdgeListGarbanzo(\n        graph_path=\"./tests/data/unweighted_edge.list\",\n        gene_path=\"./tests/data/gene.list\")\ndef test_huri():\n    data = Huri(\"./tests/data/gene.list\")\n    # maybe not the best test as only works for posix\n    assert(data.graph_path == \"/tmp/huri/huri.tsv\")\n    assert data.get(0)",
        "detail": "tests.test_garbanzo",
        "documentation": {}
    },
    {
        "label": "test_huri",
        "kind": 2,
        "importPath": "tests.test_garbanzo",
        "description": "tests.test_garbanzo",
        "peekOfCode": "def test_huri():\n    data = Huri(\"./tests/data/gene.list\")\n    # maybe not the best test as only works for posix\n    assert(data.graph_path == \"/tmp/huri/huri.tsv\")\n    assert data.get(0)\n    assert data.graph\ndef test_merge():\n    huri = Huri(\"./tests/data/gene.list\")\n    stringdb = StringDB(\"./tests/data/gene.list\")\n    merged = merge([huri, stringdb])",
        "detail": "tests.test_garbanzo",
        "documentation": {}
    },
    {
        "label": "test_merge",
        "kind": 2,
        "importPath": "tests.test_garbanzo",
        "description": "tests.test_garbanzo",
        "peekOfCode": "def test_merge():\n    huri = Huri(\"./tests/data/gene.list\")\n    stringdb = StringDB(\"./tests/data/gene.list\")\n    merged = merge([huri, stringdb])\n    assert merged.graph\n    assert list(huri.graph.nodes)[0] in merged.graph",
        "detail": "tests.test_garbanzo",
        "documentation": {}
    },
    {
        "label": "test_cv",
        "kind": 2,
        "importPath": "tests.test_hummus",
        "description": "tests.test_hummus",
        "peekOfCode": "def test_cv():\n    data = EdgeListGarbanzo(\n        graph_path=\"./tests/data/unweighted_edge.list\",\n        gene_path=\"./tests/data/gene.list\")\n    score_module = HummusScore()\n    runner = Hummus(data, with_scoring=score_module)\n    # Check if we assert gracefully in cv is not set\n    try:\n        for tester in runner:\n            ...",
        "detail": "tests.test_hummus",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def main(network_path: str, genelist_path: str, out_path: str=\"adagio.out\"):\n        graph = EdgeListGarbanzo(network_path, genelist_path)\n        model = ADAGIO()\n        model.setup(graph.graph)\n        predictions = sorted(list(model.prioritize(graph.genes)), key=lambda x: x[1])\n        with open(out_path, \"w\") as f:\n                for gene, score in predictions:\n                        f.write(f\"{gene.name}\\t{score}\\n\")\nif __name__ == \"__main__\":\n        args = parser.parse_args()",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "parser = argparse.ArgumentParser()\nparser.add_argument('--network', '-n', type=str, required=True, help=\"Path to edgelist, assumes tab separated.\")\nparser.add_argument('--genelist', '-g', type=str, required=True, help=\"Path to genelist, assumes genes are newline separated and in the network.\")\nparser.add_argument('--out', '-o', type=str, default=\"adagio.out\",help=\"Path to output results\")\ndef main(network_path: str, genelist_path: str, out_path: str=\"adagio.out\"):\n        graph = EdgeListGarbanzo(network_path, genelist_path)\n        model = ADAGIO()\n        model.setup(graph.graph)\n        predictions = sorted(list(model.prioritize(graph.genes)), key=lambda x: x[1])\n        with open(out_path, \"w\") as f:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "requirements",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "requirements = ['networkx', 'sklearn', 'pandas', 'dill', 'numpy']\ntest_requirements = ['pytest>=3', ]\nsetup(\n    author=\"Mert Erden\",\n    author_email='mert.erden@tufts.edu',\n    python_requires='>=3.8',\n    classifiers=[\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: MIT License',\n        'Natural Language :: English',",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "test_requirements",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "test_requirements = ['pytest>=3', ]\nsetup(\n    author=\"Mert Erden\",\n    author_email='mert.erden@tufts.edu',\n    python_requires='>=3.8',\n    classifiers=[\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: MIT License',\n        'Natural Language :: English',\n        'Programming Language :: Python :: 3',",
        "detail": "setup",
        "documentation": {}
    }
]